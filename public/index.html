<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&display=swap" rel="stylesheet">
  


  <meta charset="viewport" content="width=device-width, initial-scale=1.0">
  <title>ConeFlip</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    #world,
    #confetti-canvas {
      display: block;
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    #confetti-canvas {
      z-index: 2;
    }

    .userName {
      position: fixed;
      font-family: "Space Grotesk", serif;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      font-weight: bold;
      color: white;
      pointer-events: none;
      border-radius: 6px;
      transition: opacity 0.5s ease;
    }
    
    .userName.has-emote {
      background-color: transparent;
      padding: 0;
    }

    /* New CSS for winner name text so the painted gradient shows through */
    .winner-name {
      display: inline-block;
      color: white !important;
      -webkit-background-clip: text;
      background-clip: text;
    }

    /* New CSS for layered painted names */
    .paint-wrapper {
      position: relative;
      display: inline-block;
    }
    .paint-shadow {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      display: none;
    }
    .paint-text {
      position: relative;
      z-index: 2;
    }

    #celebration-container {
      display: block;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
      animation: fade-in 1s ease-in-out forwards;
    }

    .fadeoutgold {
      animation: fade-out-gold 1s ease-in-out forwards !important;
    }

    #celebration-container.hidden {
      display: none;
    }

    #player-details img {
      height: 150px;
      margin-bottom: 20px;
    }

    #player-details h1 {
      font-size: 3rem;
      font-family: "Space Grotesk", serif;
      color: gold;
      margin: 0;
    }

    #winner-container {
      display: block;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
      animation: fade-in 1s ease-in-out forwards;
     
    }

    #winner-container.hidden {
      display: none;
    }

    #winner-player-details img {
      height: 150px;
      margin-bottom: 20px;
    }
    #winner-player-name{
        color: #fff;
    }
    #winner-player-details h1 {
      font-size: 3rem;
      color: #fff;
      font-family: "Space Grotesk", serif;
      margin: 0;
      

    }

    .no7TV{
      text-shadow: #474747 3px 5px 2px;
    }

    @keyframes fade-in {
      from {
        opacity: 0;
        transform: translate(-50%, -60%);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%);
      }
    }

    @keyframes fade-out-gold {
      from {
        opacity: 1;
      }
      to {
        opacity: 0;
      }
    }

    .cone {
      position: absolute;
      height: 160px;
      width: 120px;
      will-change: transform, top, left;
      transition: opacity 0.5s ease;
      z-index: 1;
    }

    .cone_holo {
      position: absolute;
      height: 160px;
      width: 120px;
      transition: background-position 0.1s ease;
      z-index: 1;
      -webkit-mask-image: url(skins/cone_mask.png);
      mask-image: url(skins/cone_mask.png);
      mask-repeat: no-repeat;
      background-size: 400%;
      transition: opacity 0.5s ease;
    }

    /* Notification Container */
    #mk-notification {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-family: "Space Grotesk", serif;
      font-size: 30px;
      text-transform: uppercase;
      letter-spacing: 5px;
      opacity: 0;
      transition: opacity 0.5s ease;
      text-shadow:
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        2px 2px 0 #000;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }
      to {
        opacity: 0;
      }
    }

    .emote-inline {
      display: inline-block;
      vertical-align: middle;
      width: 80px;
      height: 80px;
      margin: 0px 2px;
      transform: translateY(-40px);
      object-fit: contain;
    }

    .emote-inline-winner {
      display: inline-block;
      vertical-align: middle;
      width: 200px;
      height: 200px;
      margin: 0 2px;
      object-fit: contain;
    }
  </style>
</head>

<body>
  <div id="mk-notification">ROUND 1</div>

  <canvas id="confetti-canvas"></canvas>
  <div id="celebration-container" class="hidden">
    <div id="player-details">
      <img id="player-image" src="skins/cone_gold.png">
      <h1 id="player-name"></h1>
    </div>
  </div>

  <div id="winner-container" class="hidden">
    <div id="winner-player-details">
      <h1 id="winner-player-name"></h1>
    </div>
  </div>

  <canvas id="world"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pathseg@1.2.1/pathseg.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tsparticles/confetti@3.0.3/tsparticles.confetti.bundle.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>

  <audio id="coolSound" src="O.wav"></audio>
  <audio id="failSound" src="bwomp.wav"></audio>
  <audio id="newGold" src="newGold.wav"></audio>
  <audio id="slowin" src="slowin.mp3"></audio>
  <audio id="slowout" src="slowout.mp3"></audio>
  <audio id="fight" src="fight.mp3"></audio>
  <audio id="winner" src="winner.mp3"></audio>
  <!-- Hidden SVG used as a template for the cone hitbox -->
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 488.1 645.4" style="display: none;">
    <path id="hitbox" d="M185.67,0l-101.27,509.42H14.3c-4.2,0-8.2,1.79-10.9,4.87-2.2,2.58-3.4,5.86-3.4,9.14l.3,46.21v57.44c0,4.17,1.8,8.15,4.9,10.83,2.6,2.19,5.9,3.38,9.2,3.38h459.7c3.4,0,6.7-1.19,9.2-3.38,3.2-2.68,5-6.66,4.9-10.83v-90.93l.1.1v-12.62c0-4.17-1.8-8.15-4.9-10.83-2.6-2.19-5.9-3.38-9.2-3.38h-69.9L302.92,0" />
  </svg>

  <script>
    (() => {
      const DEBUG_MODE = false;
      const slowOdds = 30;


      function convertColor(num) {
        let hexFull = (num >>> 0).toString(16).padStart(8, '0');
        let hex = hexFull.substring(0, 6);
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        return `rgb(${r}, ${g}, ${b})`;
      }

      function getPaintCSS(paint) {
        if (!paint) return null;
        if (paint.function === "LINEAR_GRADIENT") {
          const stops = paint.gradientStops
            .map(stop => `${convertColor(stop.color)} ${stop.at}`)
            .join(', ');
          let angle = "90deg";
          if (paint.gradientAngle && paint.gradientAngle !== "N/A") {
            angle = paint.gradientAngle + "deg";
          }
          return `repeating-linear-gradient(${angle}, ${stops})`;
        } else if (paint.function === "RADIAL_GRADIENT") {
          const stops = paint.gradientStops
            .map(stop => `${convertColor(stop.color)} ${stop.at}`)
            .join(', ');
          return `radial-gradient(circle, ${stops})`;
        } else if (paint.function === "URL") {
          if (paint.image) {
            return `url('${paint.image}') no-repeat center/cover`;
          }
          return null;
        } else {
          if (paint.color && paint.color !== "N/A") {
            return convertColor(paint.color);
          }
          return null;
        }
      }


      function applyPaintToName(nameElement, playerName) {
        if (!nameElement.querySelector('.paint-wrapper')) {
          let originalText = nameElement.textContent;
          nameElement.innerHTML = "";
          let wrapper = document.createElement('span');
          wrapper.className = 'paint-wrapper';
          let shadowSpan = document.createElement('span');
          shadowSpan.className = 'paint-shadow';
          shadowSpan.textContent = originalText;
          let textSpan = document.createElement('span');
          textSpan.className = 'paint-text';
          textSpan.textContent = originalText;
          wrapper.appendChild(shadowSpan);
          wrapper.appendChild(textSpan);
          nameElement.appendChild(wrapper);
        }

        let wrapper = nameElement.querySelector('.paint-wrapper');
        let textSpan = wrapper.querySelector('.paint-text');
        let shadowSpan = wrapper.querySelector('.paint-shadow');

        textSpan.classList.remove('no7TV');
        nameElement.style.display = "inline-block";
        nameElement.style.opacity = "0";
        nameElement.style.transition = "opacity 0.5s ease";

        fetch(`/api/7tv/paint?name=${encodeURIComponent(playerName)}`)
          .then(response => response.text())
          .then(text => {
            if (!text) return null;
            try {
              return JSON.parse(text);
            } catch (e) {
              console.error(`Error parsing JSON for ${playerName}:`, e);
              return null;
            }
          })
          .then(paintData => {
            if (paintData && paintData.function) {
              const cssValue = getPaintCSS(paintData);
         
              if (cssValue) {
                if (typeof CSS !== "undefined" && CSS.supports && CSS.supports("-webkit-background-clip", "text")) {

                  textSpan.style.background = cssValue;
                  textSpan.style.webkitBackgroundClip = "text";
                  textSpan.style.backgroundClip = "text";
                  textSpan.style.webkitTextFillColor = "transparent";
                  textSpan.style.color = "transparent";
                  textSpan.style.setProperty("color-shadow", "transparent", "important");
                  if (paintData.function === "URL") {
                    textSpan.style.backgroundSize = "cover";
                  }
       
                  if (paintData.shadows && Array.isArray(paintData.shadows) && paintData.shadows.length > 0) {
                    const multiplier = nameElement.classList.contains('winner-name') ? 2 : 1;
                    const filterValue = paintData.shadows
                 .map(shadow =>
                 `drop-shadow(${convertColor(shadow.color)} ${shadow.x_offset * multiplier}px ${shadow.y_offset * multiplier}px ${shadow.radius * multiplier}px)`
                 )
                 .join(' ');
                 console.log(filterValue);
                    shadowSpan.style.setProperty("filter", filterValue, "important");
                    shadowSpan.style.setProperty("text-shadow", "none", "important");
                    shadowSpan.style.display = "inline";
                  } else {
                    shadowSpan.style.display = "none";
                    textSpan.style.webkitTextStroke = "0px";
                  }
                } else {
                  applySVGGradientToName(nameElement, nameElement.textContent, paintData);
                }
              }
            } else {
              textSpan.style.background = "";
              textSpan.style.webkitBackgroundClip = "";
              textSpan.style.backgroundClip = "";
              textSpan.style.webkitTextFillColor = "";
              textSpan.style.color = "white";
              textSpan.style.backgroundSize = "";
              textSpan.style.webkitTextStroke = "";
              textSpan.classList.add('no7TV');
              shadowSpan.style.display = "none";
      
              console.log("No paint data found for " + playerName);
              
            }
      
            setTimeout(() => {
              nameElement.style.opacity = "1";
            }, 10);
          })
          .catch(error => {
            console.log(`Error fetching paint for ${playerName}:`, error);
            setTimeout(() => {
              nameElement.style.opacity = "1";
            }, 10);
          });
      }

      function applySVGGradientToName(nameElem, text, paintData) {
        const svgNS = "http://www.w3.org/2000/svg";
        const gradientId = "grad-" + Math.random().toString(36).substr(2, 9);
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", "100%");
        svg.setAttribute("height", "1em");
        svg.setAttribute("viewBox", "0 0 200 40");
        svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

        const defs = document.createElementNS(svgNS, "defs");
        const linearGradient = document.createElementNS(svgNS, "linearGradient");
        linearGradient.setAttribute("id", gradientId);
        let angle = 90;
        if (paintData.gradientAngle && paintData.gradientAngle !== "N/A") {
          angle = parseFloat(paintData.gradientAngle);
        }
        linearGradient.setAttribute("x1", "0%");
        linearGradient.setAttribute("y1", "0%");
        linearGradient.setAttribute("x2", "100%");
        linearGradient.setAttribute("y2", "0%");
        linearGradient.setAttribute("gradientTransform", `rotate(${angle})`);

        if (paintData.gradientStops && paintData.gradientStops.length > 0) {
          for (let stop of paintData.gradientStops) {
            const stopElem = document.createElementNS(svgNS, "stop");
            stopElem.setAttribute("offset", stop.at);
            stopElem.setAttribute("stop-color", convertColor(stop.color));
            linearGradient.appendChild(stopElem);
          }
        } else if (paintData.color && paintData.color !== "N/A") {
          const stopElem = document.createElementNS(svgNS, "stop");
          stopElem.setAttribute("offset", "100%");
          stopElem.setAttribute("stop-color", convertColor(paintData.color));
          linearGradient.appendChild(stopElem);
        }

        defs.appendChild(linearGradient);
        svg.appendChild(defs);

        const textElem = document.createElementNS(svgNS, "text");
        textElem.setAttribute("x", "50%");
        textElem.setAttribute("y", "50%");
        textElem.setAttribute("dominant-baseline", "middle");
        textElem.setAttribute("text-anchor", "middle");
        textElem.setAttribute("font-size", "24");
        textElem.setAttribute("fill", `url(#${gradientId})`);
        textElem.textContent = text;

        svg.appendChild(textElem);
        nameElem.innerHTML = "";
        nameElem.appendChild(svg);
      }

      const {
        Engine,
        Render,
        Runner,
        Bodies,
        Composite,
        Body,
        Events,
        Svg
      } = Matter;

      class GameManager {
        constructor() {
          this.socket = io();
          this.engine = Engine.create();
          this.world = this.engine.world;
          this.world.gravity.y = 2;

          this.render = Render.create({
            canvas: document.getElementById('world'),
            engine: this.engine,
            options: {
              width: window.innerWidth,
              height: window.innerHeight,
              wireframes: DEBUG_MODE,
              background: 'none',
            },
          });
          Render.run(this.render);
          this.runner = Runner.create();
          Runner.run(this.runner, this.engine);

          this.coneManager = new ConeManager(this);
          this.currentTopPlayer = null;
          this.playerSkins = {};
          this.isSlowMotion = false;

          this.setupGround();
          this.setupWalls();
          this.setupEvents();
          this.updatePlayerSkins();

          Events.on(this.engine, 'collisionStart', (evt) => {
            this.coneManager.handleCollision(evt);
          });
        }

        setupGround() {
          this.ground = Bodies.rectangle(
            window.innerWidth / 2,
            window.innerHeight + 10,
            window.innerWidth,
            40,
            {
              isStatic: true,
              render: { fillStyle: 'transparent', strokeStyle: 'transparent' },
              friction: 1,
              frictionStatic: 1
            }
          );
          Composite.add(this.world, this.ground);
        }

        setupWalls() {
          this.leftWall = Bodies.rectangle(
            -10,
            window.innerHeight / 2,
            20,
            window.innerHeight * 5,
            {
              isStatic: true,
              render: { fillStyle: 'transparent', strokeStyle: 'transparent' }
            }
          );

          this.rightWall = Bodies.rectangle(
            window.innerWidth + 10,
            window.innerHeight / 2,
            20,
            window.innerHeight * 5,
            {
              isStatic: true,
              render: { fillStyle: 'transparent', strokeStyle: 'transparent' }
            }
          );

          Composite.add(this.world, [this.ground, this.leftWall, this.rightWall]);
        }

        setupEvents() {
          this.socket.on('addCone', (name) => {
            this.coneManager.addCone(name);
          });
          this.socket.on('restart', () => {
            location.reload(); // This reloads the page to restart the game
          });

          this.socket.on('goldSkin', (data) => {
            this.currentTopPlayer = data;
          });

          this.socket.on('newGoldCelebration', (name) => {
            goldAnimation(name);
          });

          this.socket.on('skinRefresh', () => {
            this.updatePlayerSkins();
          });

          this.socket.on('addConeDuel', (p1, p2) => {
            this.coneManager.addConeDuel(p1, p2);
          });

          Events.on(this.engine, 'afterUpdate', () => {
            this.coneManager.updateCones();
          });

          window.addEventListener('resize', () => this.onResize());
        }

        onResize() {
          const { render, ground } = this;
          render.canvas.width = window.innerWidth;
          render.canvas.height = window.innerHeight;
          Render.setPixelRatio(render, window.devicePixelRatio);

          Body.setPosition(ground, {
            x: window.innerWidth / 2,
            y: window.innerHeight + 10,
          });
          Body.setVertices(ground, [
            { x: 0, y: window.innerHeight - 10 },
            { x: window.innerWidth, y: window.innerHeight - 10 },
            { x: window.innerWidth, y: window.innerHeight + 10 },
            { x: 0, y: window.innerHeight + 10 },
          ]);

          this.coneManager.updatePositions();
        }

        async updatePlayerSkins() {
          try {
            const resp = await fetch('/api/skins/users');
            const data = await resp.json();
            this.playerSkins = data.reduce((acc, { name, skin }) => {
              acc[name] = skin;
              return acc;
            }, {});
          } catch (err) {
            console.error('[GameManager] Error fetching skins:', err);
          }
        }

        getPlayerSkin(playerName) {
          const found = this.playerSkins[playerName] || 'default';
          return this.coneManager.availableSkins[found] || this.coneManager.availableSkins.default;
        }

        triggerSlowMotion() {
          if (this.isSlowMotion) return;
          this.isSlowMotion = true;
          this.engine.timing.timeScale = 0.1;
          document.getElementById('slowin').play();

          setTimeout(() => {
            this.engine.timing.timeScale = 1;
            this.isSlowMotion = false;
            document.getElementById('slowout').play();
          }, 3500);
        }
      }

      class ConeManager {
        constructor(gameManager) {
          this.gameManager = gameManager;
          this.cones = [];
          this.coneQueue = [];
          this.duelQueue = []; // Queue for all duels
          this.isProcessingDuel = false; // Flag to track if we're currently processing a duel
          this.positions = [
            { x: (2 * window.innerWidth) / 5, occupied: false },
            { x: (3 * window.innerWidth) / 5, occupied: false },
            { x: (4 * window.innerWidth) / 5, occupied: false },
            { x: (1 * window.innerWidth) / 5, occupied: false },
          ];
          this.duel = null;
          this.duelBodies = { bodyA: null, bodyB: null };
          this.duelCones = [];
          this.duelFailedCones = 0;

          this.availableSkins = {};
          fetch('/api/skins/available')
            .then(r => r.json())
            .then(data => {
              this.availableSkins = data;
            })
            .catch(err => console.error(err));

          const hitbox = document.querySelector('#hitbox');
          this.coneVertices = Svg.pathToVertices(hitbox).map(v => ({
            x: v.x * 0.24,
            y: v.y * 0.24,
          }));
        }

        addCone(name) {
          const position = this.positions.find(p => !p.occupied);
          if (!position) {
            this.coneQueue.push(name);
            return;
          }
          const tex = this.gameManager.getPlayerSkin(name);

          const cone = new Cone(
            name,
            position.x,
            tex,
            this.gameManager.engine,
            this.coneVertices,
            this.gameManager.world,
            this,
            this.gameManager,
            false
          );
          this.cones.push(cone);

          position.occupied = true;
          setTimeout(() => {
            position.occupied = false;
            this.processConeQueue();
          }, 5000);

          setTimeout(() => cone.launch(), 1000);
        }

        addConeDuel(p1, p2) {
          // Add duel to queue
          this.duelQueue.push({ player1: p1, player2: p2 });
          console.log(`[ConeManager] Duel queued: ${p1} vs ${p2}. Queue length: ${this.duelQueue.length}`);
          
          // Only start processing if we're not already processing a duel
          if (!this.isProcessingDuel && (!this.duel || this.duel.isFinished)) {
            this.processNextDuel();
          }
        }

        processNextDuel() {
          if (this.duelQueue.length === 0 || this.isProcessingDuel) return;
          
          this.isProcessingDuel = true;
          const nextDuel = this.duelQueue.shift();
          console.log(`[ConeManager] Processing next duel: ${nextDuel.player1} vs ${nextDuel.player2}`);

          // Check both players for emotes
          Promise.all([
            fetch(`/api/7tv/emote?name=${encodeURIComponent(nextDuel.player1)}`).then(response => response.json()),
            fetch(`/api/7tv/emote?name=${encodeURIComponent(nextDuel.player2)}`).then(response => response.json())
          ]).then(([p1Data, p2Data]) => {
            if (this.duel && !this.duel.isFinished) {
              console.log('[ConeManager] Another duel is still active, requeuing this duel');
              this.duelQueue.unshift(nextDuel);
              this.isProcessingDuel = false;
              return;
            }

            this.duel = {
              player1: nextDuel.player1,
              player2: nextDuel.player2,
              p1Result: null,
              p2Result: null,
              isFinished: false,
              p1IsEmote: p1Data.isEmote && p1Data.url ? true : false,
              p2IsEmote: p2Data.isEmote && p2Data.url ? true : false,
              p1EmoteUrl: p1Data.isEmote ? p1Data.url : null,
              p2EmoteUrl: p2Data.isEmote ? p2Data.url : null
            };

            setTimeout(() => {
              this.addDuelCone(nextDuel.player1, 0.35);
              this.addDuelCone(nextDuel.player2, 0.65);
            }, 2000);
          }).catch(error => {
            console.error('Error checking emotes:', error);
            if (this.duel && !this.duel.isFinished) {
              console.log('[ConeManager] Another duel is still active, requeuing this duel');
              this.duelQueue.unshift(nextDuel);
              this.isProcessingDuel = false;
              return;
            }

            this.duel = {
              player1: nextDuel.player1,
              player2: nextDuel.player2,
              p1Result: null,
              p2Result: null,
              isFinished: false,
              p1IsEmote: false,
              p2IsEmote: false,
              p1EmoteUrl: null,
              p2EmoteUrl: null
            };

            setTimeout(() => {
              this.addDuelCone(nextDuel.player1, 0.35);
              this.addDuelCone(nextDuel.player2, 0.65);
            }, 2000);
          });
        }

        addDuelCone(name, ratio) {
          const xPos = window.innerWidth * ratio;
          const tex = this.gameManager.getPlayerSkin(name);

          const cone = new Cone(
            name,
            xPos,
            tex,
            this.gameManager.engine,
            this.coneVertices,
            this.gameManager.world,
            this,
            this.gameManager,
            true,
            this.duel && name === this.duel.player1 ? this.duel.p1EmoteUrl : 
            this.duel && name === this.duel.player2 ? this.duel.p2EmoteUrl : null
          );
          this.cones.push(cone);

          if (!this.duelBodies.bodyA) {
            this.duelBodies.bodyA = cone.body;
            this.duelCones[0] = cone;
          } else if (!this.duelBodies.bodyB) {
            this.duelBodies.bodyB = cone.body;
            this.duelCones[1] = cone;
          }
          setTimeout(() => cone.launchDuel(ratio), 2000);
        }

        reportResult(playerName, result) {
          if (!this.duel || this.duel.isFinished) return;

          const { player1, player2, p1Result, p2Result } = this.duel;
          if (playerName !== player1 && playerName !== player2) return;

          if (playerName === player1) this.duel.p1Result = result;
          else this.duel.p2Result = result;

          if (this.duel.p1Result === 'win' && this.duel.p2Result !== 'win') {
            this.gameManager.socket.emit('fail', player2);
            this.finishDuel(player1);
            return;
          }
          if (this.duel.p2Result === 'win' && this.duel.p1Result !== 'win') {
            this.gameManager.socket.emit('fail', player1);
            this.finishDuel(player2);
            return;
          }

          if (this.duel.p1Result === 'fail' && this.duel.p2Result !== 'fail') {
            this.gameManager.socket.emit('fail', player1);
            this.finishDuel(player2);
            return;
          }
          if (this.duel.p2Result === 'fail' && this.duel.p1Result !== 'fail') {
            this.gameManager.socket.emit('fail', player2);
            this.finishDuel(player1);
            return;
          }

          if (this.duel.p1Result === 'fail' && this.duel.p2Result === 'fail') {
            this.relaunchDuelConesTowardsEachOther();
          }
        }

        finishDuel(winnerName) {
          console.log('[ConeManager] finishDuel =>', winnerName);
          if (this.duel) {
            this.duel.isFinished = true;
          }
          this.gameManager.socket.emit('win', winnerName);

          this.duelCones.forEach(cone => {
            if (cone && !cone.isRemoved) {
              cone.remove();
            }
          });

          this.duelBodies.bodyA = null;
          this.duelBodies.bodyB = null;
          this.duelCones = [];
          this.duelFailedCones = 0;
          this.duel = null;
          this.isProcessingDuel = false;

          // Process next duel in queue after a short delay
          setTimeout(() => {
            this.processNextDuel();
          }, 1000);

          triggerConfetti({ x: window.innerWidth / 2, y: window.innerHeight / 2 });
          
          const container = document.getElementById('winner-container');
          const playerNameElem = document.getElementById('winner-player-name');
          
          // Check if the winner is an emote
          fetch(`/api/7tv/emote?name=${encodeURIComponent(winnerName)}`)
            .then(response => response.json())
            .then(data => {
              if (data.isEmote && data.url) {
                // If winner is an emote, show the emote image
                playerNameElem.innerHTML = "<span class='no7TV'>Winner:</span> <br><span class='winner-name'>";
                const emoteImg = document.createElement('img');
                emoteImg.src = data.url;
                emoteImg.className = 'emote-inline-winner';
                playerNameElem.querySelector('.winner-name').appendChild(emoteImg);
                playerNameElem.querySelector('.winner-name').appendChild(document.createElement('br'));
              } else {
                // If not an emote, show normal text with paint
                playerNameElem.innerHTML = "<span class='no7TV'>Winner:</span> <br><span class='winner-name'>" + winnerName + "</span>";
                let winnerSpan = playerNameElem.querySelector('.winner-name');
                if (winnerSpan) {
                  applyPaintToName(winnerSpan, winnerName);
                }
              }
              container.classList.remove('hidden');
            })
            .catch(error => {
              console.error('Error checking emote:', error);
              // If there's an error, show normal text with paint
              playerNameElem.innerHTML = "<span class='no7TV'>Winner:</span> <br><span class='winner-name'>" + winnerName + "</span>";
              let winnerSpan = playerNameElem.querySelector('.winner-name');
              if (winnerSpan) {
                applyPaintToName(winnerSpan, winnerName);
              }
              container.classList.remove('hidden');
            });

          setTimeout(() => {
            container.classList.add('fadeoutgold');
            setTimeout(() => {
              container.classList.remove('fadeoutgold');
              container.classList.add('hidden');
            }, 1000);
          }, 4000);
        }

        relaunchDuelConesTowardsEachOther() {
          console.log('[ConeManager] Both duel cones failed on ground. Relaunching towards each other.');
          if (!this.duelCones[0] || !this.duelCones[1]) return;

          const coneA = this.duelCones[0];
          const coneB = this.duelCones[1];

          [coneA, coneB].forEach(cone => {
            cone.resetForRelaunch();
          });

          // find center point between cone A and B and launch them towards each other
          const centerCones = (coneA.body.position.x + coneB.body.position.x) / 2;
          const centerX = window.innerWidth / 2;
          const directionA = (coneA.body.position.x < centerCones) ? 1 : -1;
          const directionB = (coneB.body.position.x > centerCones) ? -1 : 1;
          const forceMagnitudeX = 1;
          const forceMagnitudeY = -2;

          Body.applyForce(coneA.body, coneA.body.position, {
            x: forceMagnitudeX * directionA,
            y: forceMagnitudeY
          });

          Body.applyForce(coneB.body, coneB.body.position, {
            x: forceMagnitudeX * directionB,
            y: forceMagnitudeY
          });

          const angularVelocityA = Math.random() * (0.2 - 0.5) + 0.05;
          const angularVelocityB = Math.random() * (0.2 - 0.5) + 0.05;
          Body.setAngularVelocity(coneA.body, angularVelocityA * directionA);
          Body.setAngularVelocity(coneB.body, angularVelocityB * directionB);

          this.duelFailedCones = 0;
        }

        processConeQueue() {
          if (!this.coneQueue.length) return;
          const nextName = this.coneQueue.shift();
          this.addCone(nextName);
        }

        updateCones() {
          this.cones.forEach(c => c.update());
        }

        updatePositions() {
          this.positions[0].x = (1 * window.innerWidth) / 5;
          this.positions[1].x = (3 * window.innerWidth) / 5;
          this.positions[2].x = (4 * window.innerWidth) / 5;
          this.positions[3].x = (2 * window.innerWidth) / 5;
        }

        removeCone(c) {
          const ix = this.cones.indexOf(c);
          if (ix !== -1) this.cones.splice(ix, 1);
        }

        handleCollision(evt) {
          if (!this.duel || !this.duelBodies.bodyA || !this.duelBodies.bodyB) return;

          for (const pair of evt.pairs) {
            const A = pair.bodyA.parent;
            const B = pair.bodyB.parent;

            const isDuelPair =
              (A === this.duelBodies.bodyA && B === this.duelBodies.bodyB) ||
              (A === this.duelBodies.bodyB && B === this.duelBodies.bodyA);

            if (isDuelPair) {
              this.applyBeybladeForce(A, B);
            }
          }
        }

        applyBeybladeForce(bodyA, bodyB) {
          const dx = bodyB.position.x - bodyA.position.x;
          const dy = bodyB.position.y - bodyA.position.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;

          const pushStrength = 4 + Math.random() * 5;
          const pushStrength2 = 4 + Math.random() * 5;
          const nx = dx / dist;
          const ny = dy / dist;

          const baseSpin = Math.random() * 0.3;
          const baseSpin2 = Math.random() * 0.3;
          const spinA = baseSpin * (Math.random() > 0.5 ? 1 : -1) * pushStrength;
          const spinB = baseSpin2 * (Math.random() > 0.5 ? 1 : -1) * pushStrength2;

          Body.setAngularVelocity(bodyA, spinA);
          Body.setAngularVelocity(bodyB, spinB);

          Body.applyForce(bodyA, bodyA.position, {
            x: -nx * pushStrength,
            y: -ny * pushStrength
          });
          Body.applyForce(bodyB, bodyB.position, {
            x: nx * pushStrength,
            y: ny * pushStrength
          });
        }

        duelConeFailed() {
          this.duelFailedCones += 1;
          console.log(`[ConeManager] Duel cone failed. Total failed: ${this.duelFailedCones}`);
          if (this.duelFailedCones >= 2 && this.duel && !this.duel.isFinished) {
            this.relaunchDuelConesTowardsEachOther();
          }
        }
      }

      class Cone {
        constructor(
          name,
          positionX,
          texture,
          engine,
          coneVertices,
          world,
          coneManager,
          gameManager,
          isDuelCone = false,
          emoteUrl = null
        ) {
          this.name = name;
          this.engine = engine;
          this.world = world;
          this.coneManager = coneManager;
          this.gameManager = gameManager;
          this.isDuelCone = isDuelCone;
          this.isRemoved = false;
          this.emoteUrl = emoteUrl;

          this.hasLaunched = false;
          this.celebrated = false;

          // Track consecutive frames nearly still
          this.stillFrameCount = 0;
          this.stillFrameThreshold = 120;

          this.body = Bodies.fromVertices(positionX, window.innerHeight - 85, coneVertices, {
            restitution: 0.2,
            density: 0.0011,
            friction: 0.4,
            frictionAir: 0.02,
            render: DEBUG_MODE
              ? { fillStyle: 'rgba(255,0,0,0.5)', visible: true }
              : { visible: false }
          }, true);
          Body.setStatic(this.body, true);
          Composite.add(this.world, this.body);

          this.nameWrapper = document.createElement('span');
          this.nameWrapper.className = 'userName';
          if (this.emoteUrl) {
            this.nameWrapper.classList.add('has-emote');
          }
          document.body.appendChild(this.nameWrapper);

          this.nameWrapper.style.opacity = "0";
          setTimeout(() => {
            this.nameWrapper.style.opacity = "1";
          }, 300);

          this.nameText = document.createElement('span');
          if (this.emoteUrl) {
            const emoteImg = document.createElement('img');
            emoteImg.src = this.emoteUrl;
            emoteImg.className = 'emote-inline';
            this.nameText.appendChild(emoteImg);
          } else {
            this.nameText.textContent = name;
            // Apply the new layered paint+shadow logic.
            applyPaintToName(this.nameText, name);
          }
          this.nameWrapper.appendChild(this.nameText);

          if (texture.includes('holo_doppler')) {
 
            this.overlay = document.createElement('img');
            this.overlay.src = 'skins/transparent.png';
            this.overlay.className = 'cone';

            this.element = document.createElement('div');
            this.element.className = 'cone_holo'; 
            const phase = Math.floor(Math.random() * 4) + 1;
            this.element.style.backgroundImage = `url(${texture}_${phase}.jpg)`;
            console.log(`[Cone] ${this.name} has holo_doppler with phase ${phase} url(${texture}_${phase}.jpg)`);
            this.element.appendChild(this.overlay);
          } else if (texture.includes('holo_')) {
            this.overlay = document.createElement('img');
            this.overlay.src = 'skins/transparent.png';
            this.overlay.className = 'cone';

            this.element = document.createElement('div');
            this.element.className = 'cone_holo';
            this.element.style.backgroundImage = `url(${texture})`;
            this.element.appendChild(this.overlay);
          } else {
            this.element = document.createElement('img');
            this.element.src = texture;
            this.element.className = 'cone';
          }
          document.body.appendChild(this.element);

          this.element.style.opacity = "0";
          setTimeout(() => {
            this.element.style.opacity = "1";
          }, 300);

          this.updateNameLabelPosition();
        }

        launch() {
          if (this.isDuelCone) {
            this.launchDuel(0.5);
            return;
          }
          Body.setStatic(this.body, false);
          this.applyRandomUpwardForceAndSpin();
          this.hasLaunched = true;

          setTimeout(() => {
            if (Math.random() < 1 / slowOdds) {
              this.gameManager.triggerSlowMotion();
            }
          }, 500);
        }

        launchDuel(ratio) {
          Body.setStatic(this.body, false);

          const dir = ratio < 0.5 ? 1 : -1;
          const horizontalForce = 0.5 * dir;
          const upwardForce = 1.6;

          Body.applyForce(this.body, this.body.position, {
            x: horizontalForce,
            y: -upwardForce
          });

          const spinVelocity = 0.1;
          const spinDir = Math.random() > 0.5 ? 1 : -1;
          Body.setAngularVelocity(this.body, spinVelocity * spinDir);

          this.hasLaunched = true;
        }

        applyRandomUpwardForceAndSpin() {
          const base = 1.63;
          const total = base + Math.random() * 0.2;
          const xforce = (Math.random() - 0.5) * 0.4;
          Body.applyForce(this.body, this.body.position, {
            x: xforce,
            y: -total
          });

          const spin = 0.2 + Math.random() * 0.8;
          const dir = Math.random() > 0.5 ? 1 : -1;
          Body.setAngularVelocity(this.body, spin * dir);
        }

        update() {
          this.updatePosition();
          this.updateNameLabelPosition();
          this.handleStationary();
          this.checkOffScreen();
        }

        updatePosition() {
          if (!this.element) return;
          const { x, y } = this.body.position;
          const angle = this.body.angle;

          const w = 488, h = 645;
          const scale = 0.24;
          const cW = w * scale, cH = h * scale;
          const xOffset = cW / 2, yOffset = cH / 2;

          const vertAdjust = -17, horizAdjust = -1;
          const adjustedX = x + horizAdjust * Math.cos(angle) - vertAdjust * Math.sin(angle);
          const adjustedY = y + vertAdjust * Math.cos(angle) + horizAdjust * Math.sin(angle);

          this.element.style.top = `${adjustedY - yOffset}px`;
          this.element.style.left = `${adjustedX - xOffset}px`;
          this.element.style.backgroundPositionY = `${(adjustedY - yOffset) / 2}px`;
          this.element.style.backgroundPositionX = `${(adjustedX - xOffset) / 2}px`;
          this.element.style.transform = `rotate(${angle}rad)`;
          this.element.style.transformOrigin = 'center center';
        }

        updateNameLabelPosition() {
          if (!this.nameWrapper) return;
          this.nameWrapper.style.top = `${this.body.position.y - 150}px`;
          this.nameWrapper.style.left = `${this.body.position.x - this.nameWrapper.offsetWidth / 2}px`;
        }

        handleStationary() {
          if (!this.hasLaunched) return;
          const still =
            Math.abs(this.body.velocity.x) < 0.12 &&
            Math.abs(this.body.velocity.y) < 0.12 &&
            Math.abs(this.body.angularVelocity) < 0.12;

          if (still) {
            // Clamp tiny velocities to zero to stop jitter
            if (Math.abs(this.body.velocity.x) < 0.12) this.body.velocity.x = 0;
            if (Math.abs(this.body.velocity.y) < 0.12) this.body.velocity.y = 0;
            if (Math.abs(this.body.angularVelocity) < 0.12) this.body.angularVelocity = 0;
            this.stillFrameCount++;
          } else {
            this.stillFrameCount = 0;
            this.celebrated = false;
          }

          if (!this.celebrated && this.stillFrameCount > this.stillFrameThreshold) {
            this.celebrated = true;
            const uprightOrUpsideDown = this.isUprightOrUpsideDown();
            console.log(`[Cone] ${this.name} isUprightOrUpsideDown: ${uprightOrUpsideDown}, Angle: ${this.body.angle.toFixed(2)} radians`);
            if (uprightOrUpsideDown) {
              document.getElementById('coolSound').play();
              triggerConfetti(this.body.position);
              if (this.isDuelCone) {
                this.coneManager.reportResult(this.name, 'win');
              } else {
                this.gameManager.socket.emit('win', this.name);
              }
              this.startFadeOut();
            } else {
              if (this.isDuelCone && this.coneManager.duel && !this.coneManager.duel.isFinished) {
                this.coneManager.duelConeFailed();
              } else {
                console.log(`[Cone] Regular cone "${this.name}" failed on ground. Removing.`);
                this.gameManager.socket.emit('fail', this.name);
                document.getElementById('failSound').play();
                this.startFadeOut();
              }
            }
          }
        }

        resetForRelaunch() {
          Body.setPosition(this.body, {
            x: this.body.position.x,
            y: window.innerHeight - 85
          });
          Body.setVelocity(this.body, { x: 0, y: 0 });
          Body.setAngularVelocity(this.body, 0);

          Body.setStatic(this.body, false);
          this.hasLaunched = true;
          this.celebrated = false;
          this.stillFrameCount = 0;
        }

        isUprightOrUpsideDown() {
          let a = this.body.angle % (2 * Math.PI);
          if (a < 0) a += 2 * Math.PI;
          const eps = 0.35;
          // Check for upright (0) or upside down (π)
          return (a < eps || a > 2 * Math.PI - eps || Math.abs(a - Math.PI) < eps);
        }

        checkOffScreen() {
          const floorY = window.innerHeight + 1000;
          const { y } = this.body.position;
          if (y > floorY) {
            if (this.isDuelCone && this.coneManager.duel && !this.coneManager.duel.isFinished) {
              const duel = this.coneManager.duel;
              if (duel && !duel.isFinished) {
                const { player1, player2 } = duel;
                const loser = this.name;
                const winner = (loser === player1) ? player2 : player1;
                this.coneManager.reportResult(loser, 'fail');
              } else {
                this.coneManager.reportResult(this.name, 'fail');
              }
            }
            this.remove();
          }
        }

        startFadeOut() {
          if (!DEBUG_MODE) {
            this.element.style.opacity = '0';
            this.nameWrapper.style.opacity = '0';
            setTimeout(() => this.remove(), 500);
          } else {
            this.remove();
          }
        }

        remove() {
          if (this.isRemoved) return;
          this.isRemoved = true;

          if (this.nameWrapper) this.nameWrapper.remove();
          if (this.element) this.element.remove();
          Composite.remove(this.world, this.body);

          this.coneManager.removeCone(this);
        }
      }

      const triggerConfetti = (pos) => {
        const origin = {
          x: pos.x / window.innerWidth,
          y: Math.max(0, Math.min(1, (pos.y - 120) / window.innerHeight)),
        };
        const steps = [
          { spread: 26, startVelocity: 55, particleCount: 50 },
          { spread: 60, particleCount: 40 },
          { spread: 100, decay: 0.91, scalar: 0.8, particleCount: 70 },
          { spread: 120, startVelocity: 25, decay: 0.92, scalar: 1.2, particleCount: 20 },
          { spread: 120, startVelocity: 45, particleCount: 20 },
        ];
        steps.forEach((opts) => confetti({ origin, ...opts }));
      };

      const goldAnimation = (playerName) => {
        document.getElementById('newGold').play();
        const container = document.getElementById('celebration-container');
        const playerNameElement = document.getElementById('player-name');

        playerNameElement.textContent = playerName;
        container.classList.remove('hidden');

        triggerConfetti({ x: window.innerWidth / 2, y: window.innerHeight / 2 });

        setTimeout(() => {
          container.classList.add('fadeoutgold');
          setTimeout(() => {
            container.classList.remove('fadeoutgold');
            container.classList.add('hidden');
          }, 1000);
        }, 4000);
      };

      function showMortalKombatNotification(name1, name2) {
        const notification = document.getElementById('mk-notification');
        notification.style.opacity = '1';
        notification.textContent = name1 + " VS " + name2;
        notification.style.animation = 'fadeIn 0.5s forwards';

        setTimeout(() => {
          notification.innerHTML = '<img src="fight.png" alt="FIGHT" style="width: 100%; height: auto; max-width: 500px;">';
        }, 1500);

        setTimeout(() => {
          notification.style.animation = 'fadeOut 0.5s forwards';
          notification.addEventListener('animationend', () => {
            notification.innerHTML = '';
          }, { once: true });
        }, 3000);
      }

      const gameManager = new GameManager();
    })();
  </script>
</body>

</html>
